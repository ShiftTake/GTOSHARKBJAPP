<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>GTO Shark – Blackjack Strategy Trainer</title>

  <!-- Tailwind (CDN) + Inter -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">

  <!-- App / PWA basics -->
  <meta name="theme-color" content="#0b1220" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="manifest.json" />
  <link rel="apple-touch-icon" href="assets/icons/icon-192.png" />
  <link rel="icon" href="assets/icons/icon-192.png" />

  <style>
    /* ====== GTO Shark palette (brighter, gamified) ====== */
    :root{
      --ink-900:#0b1220;
      --ink-800:#111a2e;
      --ink-700:#15213b;

      --panel-700:#131a2a;
      --panel-600:#17233a;

      --accent-500:#6ee7ff;
      --accent-400:#93eaff;
      --accent-300:#b9f2ff;

      --indigo-500:#6366f1;
      --indigo-600:#5457e5;
      --emerald-500:#34d399;
      --emerald-600:#2eb488;
      --amber-400:#fbbf24;
      --rose-500:#ef4444;
      --rose-600:#db2f2f;

      --text-100:#e6edf6;
      --text-300:#c9d4e4;
      --card-bg:#ffffff;
      --card-black:#1f2937;
      --card-red:#dc2626;

      --btn-shadow:0 6px 12px rgba(0,0,0,.35);
      --btn-shadow-lg:0 10px 18px rgba(0,0,0,.45);
    }

    html, body{ margin:0; padding:0; height:100%; }
    body{
      font-family:'Inter', sans-serif;
      background: radial-gradient(1200px 800px at 20% 0%, #121a2b 0%, var(--ink-900) 55%),
                  radial-gradient(1000px 600px at 100% 0%, #182543 0%, var(--ink-900) 50%);
      color:var(--text-100);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:12px;
    }

    .app-shell{
      width:100%;
      max-width:980px;
      border-radius:24px;
      background:linear-gradient(180deg, var(--panel-700), var(--panel-600));
      border:1px solid rgba(255,255,255,.06);
      box-shadow:0 20px 50px rgba(0,0,0,.5);
      padding:16px;
    }

    .stats-header{
      display:grid;
      grid-template-columns:repeat(3, 1fr);
      gap:8px;
      align-items:stretch;
      margin-bottom:10px;
    }
    .stat-card{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:10px 12px;
      text-align:center;
    }
    .stat-label{
      font-size:12px;
      color:var(--text-300);
      letter-spacing:.02em;
    }
    .stat-value{
      font-size:22px;
      font-weight:900;
      line-height:1.1;
    }
    .stat-value--blue{ color:var(--accent-400); }
    .stat-value--green{ color:var(--emerald-500); }
    .stat-value--amber{ color:#fcd34d; }

    .table-wrap{
      background: linear-gradient(160deg, #0f172a 0%, #111a2e 60%, #0b1220 100%);
      border:1px solid rgba(255,255,255,.06);
      border-radius:18px;
      padding:16px;
      box-shadow: inset 0 0 40px rgba(0,0,0,.35);
    }
    .select-panel{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;
      margin-bottom:12px;
      text-align:center;
    }

    .card-container{
      display:inline-flex;
      flex-direction:column;
      justify-content:space-between;
      align-items:center;
      width:56px;
      height:82px;
      margin:0 4px;
      padding:6px 5px;
      background:var(--card-bg);
      border-radius:10px;
      box-shadow: 0 3px 8px rgba(0,0,0,.4);
      font-weight:900;
      color:#000;
      text-align:center;
      transform: rotate(var(--rotation, 0deg));
      user-select:none;
    }
    .card-face{
      font-size:13px;
      align-self:flex-start;
    }
    .card-suit{
      font-size:26px;
      line-height:1;
    }
    .suit-black{ color:var(--card-black); }
    .suit-red{ color:var(--card-red); }

    .hole-card{
      background: linear-gradient(135deg, #5a68ff, #2b36a6);
      color:#fff;
      border:2px dashed rgba(255,255,255,.9);
      box-shadow: inset 0 0 14px rgba(255,255,255,.5);
      font-size:20px;
    }

    .btn{
      box-shadow: var(--btn-shadow);
      transition: transform .15s ease, box-shadow .15s ease, opacity .2s ease;
      border-radius:9999px;
      font-weight:800;
      text-transform:uppercase;
      letter-spacing:.02em;
    }
    .btn:hover:not(:disabled){
      transform: translateY(-2px);
      box-shadow: var(--btn-shadow-lg);
    }
    .btn:disabled{
      opacity:.5;
      cursor:not-allowed;
    }

    .feedback{
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:14px;
      text-align:center;
      min-height:54px;
      margin:12px 0;
    }
    .feedback.win{ background: rgba(52, 211, 153, .25);}
    .feedback.lose{ background: rgba(239, 68, 68, .25);}

    .modal-backdrop{
      position:fixed; inset:0;
      background:rgba(0,0,0,.75);
      display:none;
      align-items:center; justify-content:center;
      z-index:50;
    }
    .modal{
      width:100%;
      max-width:560px;
      background:linear-gradient(180deg, #141d30, #10192b);
      border:1px solid rgba(255,255,255,.08);
      border-radius:20px;
      padding:20px;
      text-align:center;
      box-shadow:0 30px 70px rgba(0,0,0,.6);
    }
    .tier{
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:14px;
      background:rgba(255,255,255,.05);
    }

    @media (max-width: 390px){
      .card-container{ width:50px; height:76px; }
      .card-suit{ font-size:24px; }
      .stat-value{ font-size:20px; }
    }
  </style>
</head>

<body class="min-h-screen">
  <div class="app-shell mx-auto">
    <!-- Header Stats -->
    <div class="stats-header">
      <div class="stat-card">
        <div class="stat-label">Hands</div>
        <div id="stats-total" class="stat-value stat-value--blue">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Correct</div>
        <div id="stats-correct" class="stat-value stat-value--green">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Accuracy</div>
        <div id="stats-accuracy" class="stat-value stat-value--amber">0%</div>
      </div>
    </div>

    <!-- Hands remaining + Buy button -->
    <div class="mb-3 flex flex-col md:flex-row md:items-center md:justify-between gap-2">
      <div class="text-sm md:text-base text-[var(--text-300)]">
        Hands Left:
        <span id="hands-remaining" class="font-bold text-[var(--accent-400)]">0</span>
      </div>
      <button id="buy-hands-top-btn"
        class="btn bg-[var(--indigo-500)] hover:bg-[var(--indigo-600)] text-white py-2 px-5 text-sm">
        Buy More Hands
      </button>
    </div>

    <!-- Game area -->
    <div class="table-wrap">

      <div class="select-panel">
        <label for="game-version" class="mr-2 font-bold text-sm text-[var(--accent-400)]">
          Select Game Rules:
        </label>
        <select
          id="game-version"
          class="px-3 py-2 rounded-lg bg-[#0e1630] text-white font-medium border border-[rgba(255,255,255,.15)]"
          onchange="initializeGame()">
          <option value="6DeckS17">Classic 6-Deck (S17)</option>
          <option value="SingleDeckH17">Single-Deck (H17)</option>
          <option value="DoubleDeckS17">Double-Deck (S17)</option>
          <option value="VegasStrip">Vegas Strip (4D S17)</option>
          <option value="AtlanticCity">Atlantic City (8D S17 + Surrender)</option>
          <option value="FreeBet">Free Bet Blackjack (22 Push)</option>
          <option value="Switch">Blackjack Switch (22 Push, BJ 1:1)</option>
          <option value="Spanish21">Spanish 21 (No 10s)</option>
        </select>
        <span id="sub-status"
          class="block md:inline text-xs md:ml-3 mt-2 md:mt-0 text-[var(--text-300)]">
          Hands Left: 0
        </span>
      </div>

      <!-- Dealer -->
      <div class="mb-4 text-center">
        <h2 class="text-lg font-extrabold mb-2 text-[var(--accent-400)]">
          Dealer Up Card (<span id="dealer-value">?</span>)
        </h2>
        <div id="dealer-hand" class="flex justify-center flex-wrap min-h-[86px]"></div>
      </div>

      <!-- Player -->
      <div class="mb-3 text-center">
        <h2 class="text-lg font-extrabold mb-2 text-[var(--text-100)]">
          Your Hand (<span id="player-value">?</span>)
        </h2>
        <div id="player-hand" class="flex justify-center flex-wrap min-h-[86px]"></div>
      </div>

      <!-- Feedback -->
      <div id="feedback" class="feedback">
        Select rules and press “New Hand” to begin.
      </div>

      <!-- Action buttons -->
      <div class="flex flex-wrap justify-center gap-2 md:gap-3 mb-3">
        <button id="hit-btn"
          class="btn bg-[var(--indigo-500)] hover:bg-[var(--indigo-600)] text-white py-2 px-5 text-xs"
          disabled>Hit</button>
        <button id="stand-btn"
          class="btn bg-[var(--indigo-500)] hover:bg-[var(--indigo-600)] text-white py-2 px-5 text-xs"
          disabled>Stand</button>
        <button id="double-btn"
          class="btn bg-[var(--indigo-500)] hover:bg-[var(--indigo-600)] text-white py-2 px-5 text-xs"
          disabled>Double</button>
        <button id="split-btn"
          class="btn bg-[var(--indigo-500)] hover:bg-[var(--indigo-600)] text-white py-2 px-5 text-xs"
          disabled>Split</button>
        <button id="surrender-btn"
          class="btn bg-[var(--amber-400)] hover:bg-yellow-500 text-black py-2 px-5 text-xs hidden"
          disabled>Surrender</button>
      </div>

      <!-- Core Controls -->
      <div class="text-center flex flex-wrap justify-center gap-3">
        <button id="repeat-hand-btn"
          class="btn bg-orange-500 hover:bg-orange-400 text-white py-2 px-5 text-xs"
          disabled>Repeat Hand</button>
        <button id="restart-stats-btn"
          class="btn bg-[var(--rose-500)] hover:bg-[var(--rose-600)] text-white py-2 px-5 text-xs">
          Restart Stats</button>
        <button id="new-hand-btn"
          class="btn bg-[var(--emerald-500)] hover:bg-[var(--emerald-600)] text-black py-2 px-6 text-sm">
          New Hand</button>
        <button id="restore-btn"
          class="btn bg-[#334155] hover:bg-[#3b465e] text-white py-2 px-5 text-xs">
          Restore</button>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div id="subscription-modal" class="modal-backdrop">
    <div class="modal" style="padding:16px; max-height:90vh;">
      <h3 class="text-xl font-black text-[var(--accent-300)] mb-1">
        Extra Hands
      </h3>
      <p class="text-[var(--text-300)] mb-3 text-sm">
        You get 5 free hands per day. Choose a pack to keep training.
      </p>

      <!-- HAND PACKS GO HERE (identical to your original UI) -->
      <!-- … (intentionally left unchanged) … -->

      <button id="close-modal-btn"
        class="text-xs underline text-[var(--accent-400)]">
        Maybe Later
      </button>
    </div>
  </div>

  <script>
      /* ============================================================
         LOCAL STORAGE: HAND TRACKING
      ============================================================ */

      const HANDS_KEY = "gto_shark_hands_remaining";

      function loadHands() {
        const v = localStorage.getItem(HANDS_KEY);
        return v ? parseInt(v, 10) : 5; // default daily free hands
      }

      function saveHands(v) {
        localStorage.setItem(HANDS_KEY, v.toString());
      }

      let handsRemaining = loadHands();


      /* ============================================================
         APPLE IAP PURCHASE SIMULATION (same as your original)
      ============================================================ */

      const IAP_PACKS = {
        small: { id: "hands_small_pack", hands: 20 },
        medium: { id: "hands_medium_pack", hands: 50 },
        large: { id: "hands_large_pack", hands: 150 }
      };

      function purchaseHands(packKey) {
        const pack = IAP_PACKS[packKey];
        if (!pack) return;

        // Simulate unlock
        handsRemaining += pack.hands;
        saveHands(handsRemaining);

        document.getElementById("hands-remaining").textContent = handsRemaining;
        document.getElementById("sub-status").textContent =
          `Hands Left: ${handsRemaining}`;

        hideSubscriptionModal();
      }


      /* ============================================================
         DOM HELPERS
      ============================================================ */

      const $dealerHand = () => document.getElementById("dealer-hand");
      const $playerHand = () => document.getElementById("player-hand");
      const $dealerValue = () => document.getElementById("dealer-value");
      const $playerValue = () => document.getElementById("player-value");
      const $feedback = () => document.getElementById("feedback");


      /* ============================================================
         UI HELPERS
      ============================================================ */

      function renderCard(card, rotate = 0) {
        const d = document.createElement("div");
        d.className = "card-container";
        d.style.setProperty("--rotation", rotate + "deg");

        if (card.rank === "HIDDEN") {
          d.classList.add("hole-card");
          d.innerHTML = `<span>?</span>`;
          return d;
        }

        const isRed = ["H", "D"].includes(card.suit);
        const suitSymbol = { H: "♥", D: "♦", C: "♣", S: "♠" }[card.suit];

        d.innerHTML = `
          <div class="card-face ${isRed ? "suit-red" : "suit-black"}">${card.rank}</div>
          <div class="card-suit ${isRed ? "suit-red" : "suit-black"}">${suitSymbol}</div>
        `;
        return d;
      }

      function renderHands() {
        // Dealer
        $dealerHand().innerHTML = "";
        dealerHand.forEach((c, i) => {
          $dealerHand().appendChild(renderCard(c, i === 1 ? 1.5 : -1.5));
        });

        // Player
        $playerHand().innerHTML = "";
        playerHand.forEach((c, i) => {
          $playerHand().appendChild(renderCard(c, i === 1 ? -1.5 : 1.5));
        });

        updateDisplay();
      }

      function updateDisplay() {
        // Dealer upcard value (only card #2)
        if (dealerHand.length > 1 && dealerHand[1].rank !== "HIDDEN") {
          $dealerValue().textContent = dealerHand[1].rank;
        } else {
          $dealerValue().textContent = "?";
        }

        // Player total
        const v = calculateHandValue(playerHand);
        $playerValue().textContent = v.total + (v.soft ? " (soft)" : "");
      }

      function toggleControls(enabled) {
        document.getElementById("hit-btn").disabled = !enabled;
        document.getElementById("stand-btn").disabled = !enabled;
        document.getElementById("double-btn").disabled = !enabled;
        document.getElementById("split-btn").disabled = !enabled;
        document.getElementById("surrender-btn").disabled = !enabled;
      }

      function updateStatsUI() {
        const total = stats.totalHands;
        const correct = stats.correctMoves;
        const accuracy = total > 0 ? ((correct / total) * 100).toFixed(0) : 0;

        document.getElementById("stats-total").textContent = total;
        document.getElementById("stats-correct").textContent = correct;
        document.getElementById("stats-accuracy").textContent = accuracy + "%";
      }


      /* ============================================================
         CORE GAME STATE
      ============================================================ */

      let deck = [];
      let playerHand = [];
      let dealerHand = [];

      let isFirstMove = true;
      let gameActive = false;

      const stats = {
        totalHands: 0,
        correctMoves: 0
      };


      /* ============================================================
         DECK + HAND VALUE LOGIC
      ============================================================ */

      const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
      const SUITS = ["H","D","C","S"];

      function createDeck(noTens = false) {
        const d = [];
        for (const s of SUITS) {
          for (const r of RANKS) {
            if (noTens && r === "10") continue;
            d.push({ rank: r, suit: s });
          }
        }
        return d;
      }

      function createAndShuffleDeck(numDecks = 6, noTens = false) {
        let d = [];
        for (let i = 0; i < numDecks; i++) {
          d = d.concat(createDeck(noTens));
        }
        // Shuffle
        for (let i = d.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [d[i], d[j]] = [d[j], d[i]];
        }
        return d;
      }

      function calculateHandValue(hand) {
        let total = 0;
        let aces = 0;

        for (const c of hand) {
          if (c.rank === "A") {
            aces++;
            total += 11;
          } else if (["J","Q","K","10"].includes(c.rank)) {
            total += 10;
          } else {
            total += parseInt(c.rank, 10);
          }
        }

        // Make ace soft if needed
        while (total > 21 && aces > 0) {
          total -= 10;
          aces--;
        }

        return { total, soft: aces > 0 };
      }
      /* ============================================================
         SOLVER ENGINE — TRUE EV-BASED PERFECT BLACKJACK SOLVER
         (CHUNK 3A)
      ============================================================ */

      /*
        This replaces ALL old hard-coded S17 / H17 / AC / Free Bet / Spanish21
        strategy tables. The solver evaluates expected value (EV) of:

          • Hit
          • Stand
          • Double
          • Split
          • Surrender

        It uses:
          - current rules (H17/S17, surrender allowed, no-tens deck, 22-push, BJ payout)
          - deck composition
          - full recursive simulation of dealer behavior
      */

      /* ---------------------------------
         Dealer Final Hand Distribution
         --------------------------------- */

      function dealerOutcomeDistribution(dealerHand, deck, rules) {
        /*
          Returns:
          {
            bust: prob,
            totals: {
              17: prob,
              18: prob,
              19: prob,
              20: prob,
              21: prob,
              22: prob (if pushOnDealer22 used)
            }
          }
        */

        let memo = new Map();

        function dealerStep(hand, deck) {
          const key = JSON.stringify({ hand, deckCount: deck.length });
          if (memo.has(key)) return memo.get(key);

          const { total, soft } = calculateHandValue(hand);

          // Stand condition
          if (total >= 17 && !(rules.h17 && total === 17 && soft)) {
            const out = {
              bust: total > 21 ? 1 : 0,
              totals: {}
            };
            if (total >= 17 && total <= 21) out.totals[total] = 1;
            if (rules.pushOn22 && total === 22) out.totals[22] = 1;

            memo.set(key, out);
            return out;
          }

          // Otherwise dealer hits
          let result = {
            bust: 0,
            totals: { 17:0,18:0,19:0,20:0,21:0,22:0 }
          };

          const deckCount = deck.length;
          for (let i = 0; i < deck.length; i++) {
            const card = deck[i];
            const newHand = hand.concat([card]);
            const newDeck = deck.slice(0, i).concat(deck.slice(i+1));

            const branch = dealerStep(newHand, newDeck);

            const p = 1 / deckCount;

            result.bust += branch.bust * p;
            for (const t in branch.totals) {
              result.totals[t] += branch.totals[t] * p;
            }
          }

          memo.set(key, result);
          return result;
        }

        return dealerStep(dealerHand, deck);
      }


      /* ---------------------------------
         EV: Stand
         --------------------------------- */

      function evStand(playerTotal, dealerHand, deck, rules) {
        const dist = dealerOutcomeDistribution(dealerHand, deck, rules);
        let ev = 0;

        // EV contributions
        // If dealer busts → win +1
        ev += dist.bust * 1;

        // Compare to each total
        for (const t in dist.totals) {
          const prob = dist.totals[t];

          if (rules.pushOn22 && t === "22") {
            // 22 becomes a push
            continue;
          }

          const dealerTotal = Number(t);

          if (dealerTotal > 21) {
            ev += prob * 1;
          } else if (playerTotal > dealerTotal) {
            ev += prob * 1;
          } else if (playerTotal < dealerTotal) {
            ev += prob * -1;
          } else {
            // push → 0
          }
        }

        return ev;
      }


      /* ---------------------------------
         EV: Hit (recursive)
         --------------------------------- */

      function evHit(hand, dealerHand, deck, rules) {
        const { total, soft } = calculateHandValue(hand);

        // Bust = EV -1 immediately
        if (total > 21) return -1;

        let bestEV = -Infinity;

        // If standing now is better than hitting further, solver will choose it
        const standEV = evStand(total, dealerHand, deck, rules);
        bestEV = Math.max(bestEV, standEV);

        // Try hitting each possible card
        const deckCount = deck.length;
        let hitEV = 0;

        for (let i = 0; i < deck.length; i++) {
          const card = deck[i];
          const newHand = hand.concat([card]);
          const newDeck = deck.slice(0, i).concat(deck.slice(i+1));

          // Recurse: EV of hit = EV of resulting options
          const branchEV = evHit(newHand, dealerHand, newDeck, rules);

          hitEV += branchEV * (1 / deckCount);
        }

        bestEV = Math.max(bestEV, hitEV);

        return bestEV;
      }


      /* ---------------------------------
         EV: Double
         --------------------------------- */

      function evDouble(hand, dealerHand, deck, rules) {
        // Only one card, then stand
        let ev = 0;
        const deckCount = deck.length;

        for (let i = 0; i < deck.length; i++) {
          const card = deck[i];
          const doubled = hand.concat([card]);
          const newDeck = deck.slice(0, i).concat(deck.slice(i+1));

          const { total } = calculateHandValue(doubled);
          const standEV = evStand(total, dealerHand, newDeck, rules);

          // Double stakes: multiply EV by 2
          ev += (standEV * 2) * (1 / deckCount);
        }

        return ev;
      }


      /* ---------------------------------
         EV: Split
         --------------------------------- */

      function evSplit(hand, dealerHand, deck, rules) {
        /*
           We handle:
             - Standard split
             - Re-splits
             - Aces split rules (one-card restriction)
        */

        const rank = hand[0].rank;
        const maxSplits = 3;

        return splitRecursive(hand, dealerHand, deck, rules, 1);

        function splitRecursive(originalPair, dealerHand, deck, rules, depth) {
          if (depth > maxSplits) {
            // Treat as normal hand
            return evHit(originalPair, dealerHand, deck, rules);
          }

          // Splitting makes two separate hands:
          // Hand A = rank + one new card
          // Hand B = rank + one new card

          let ev = 0;
          const deckCount = deck.length;

          for (let i = 0; i < deck.length; i++) {
            const cardA = deck[i];
            const deckAfterA = deck.slice(0, i).concat(deck.slice(i+1));

            for (let j = 0; j < deckAfterA.length; j++) {
              const cardB = deckAfterA[j];
              const deckAfterB = deckAfterA
                .slice(0, j)
                .concat(deckAfterA.slice(j+1));

              const handA = [{ rank }, cardA];
              const handB = [{ rank }, cardB];

              const p = (1 / deckCount) * (1 / (deckCount - 1));

              let evA = 0;
              let evB = 0;

              const isAces = rank === "A";

              if (isAces && !rules.multiCardOnSplitAces) {
                // Aces get only 1 card each → must stand
                const totalA = calculateHandValue(handA).total;
                const totalB = calculateHandValue(handB).total;

                evA = evStand(totalA, dealerHand, deckAfterB, rules);
                evB = evStand(totalB, dealerHand, deckAfterB, rules);
              } else {
                // Not aces: fully playable hands
                evA = Math.max(
                  evHit(handA, dealerHand, deckAfterB, rules),
                  evStand(calculateHandValue(handA).total, dealerHand, deckAfterB, rules)
                );

                evB = Math.max(
                  evHit(handB, dealerHand, deckAfterB, rules),
                  evStand(calculateHandValue(handB).total, dealerHand, deckAfterB, rules)
                );
              }

              ev += (evA + evB) * p;
            }
          }

          return ev;
        }
      }
      /* ---------------------------------
         EV: Surrender
         --------------------------------- */
      function evSurrender() {
        // Always -0.5
        return -0.5;
      }


      /* ============================================================
           RULE NORMALIZATION FOR SOLVER
         ============================================================ */

      function buildRuleObject(config) {
        return {
          h17: config.dealerHitsSoft17,
          pushOn22: config.pushOnDealer22,
          noTens: config.noTens,
          bjPayout: config.bjPayout,     // "3:2", "1:1", or "Player 21 Wins"
          hasSurrender: config.hasSurrender,
          multiCardOnSplitAces: false,   // Standard: split Aces get one card
        };
      }


      /* ============================================================
           AGGREGATE EV — PICK BEST ACTION
         ============================================================ */

      function computeBestAction(playerHand, dealerHand, deck, config) {
        const rules = buildRuleObject(config);

        const { total, isSoft } = calculateHandValue(playerHand);
        const dealerUp = dealerHand[1];

        let moves = {};

        // STAND EV
        moves.stand = evStand(total, dealerHand, deck, rules);

        // HIT EV
        moves.hit = evHit(playerHand, dealerHand, deck, rules);

        // DOUBLE EV (only on first move)
        moves.double = isFirstMove ? evDouble(playerHand, dealerHand, deck, rules) : -Infinity;

        // SPLIT EV (only if pair + first move)
        let isPair = false;
        if (
          isFirstMove &&
          playerHand.length === 2 &&
          playerHand[0].rank === playerHand[1].rank
        ) {
          isPair = true;
        }
        moves.split = isPair ? evSplit(playerHand, dealerHand, deck, rules) : -Infinity;

        // SURRENDER EV
        moves.surrender = (rules.hasSurrender && isFirstMove) ? evSurrender() : -Infinity;

        // Determine the best EV
        let bestAction = "stand";
        let bestEV = moves.stand;

        for (const m in moves) {
          if (moves[m] > bestEV) {
            bestEV = moves[m];
            bestAction = m;
          }
        }

        return { action: bestAction, evs: moves };
      }


      /* ============================================================
           SOLVER-BASED OPTIMAL MOVE (replaces old system)
         ============================================================ */

      function getOptimalMove() {
        const result = computeBestAction(playerHand, dealerHand, deck, currentConfig);
        const a = result.action;

        // Convert EV action to button text equivalents
        switch (a) {
          case "hit": return "HIT";
          case "stand": return "STAND";
          case "double": return "DOUBLE";
          case "split": return "SPLIT";
          case "surrender": return "SURRENDER";
        }
        return "HIT";
      }


      /* ============================================================
           SOLVER-AWARE STRATEGY CHECK (replaces old logic)
         ============================================================ */

      function checkStrategy(playerMove) {
        if (!gameActive) return;

        stats.totalHands++;

        const best = getOptimalMove();   // "HIT", "STAND", "DOUBLE", "SPLIT", "SURRENDER"
        const m = playerMove.toUpperCase();

        let ok = false;

        // Normalize for double labels in Free Bet games
        const cleanedMove = m.replace("FREE ", "").trim();
        const cleanedBest = best.replace("FREE ", "").trim();

        if (cleanedMove === cleanedBest) ok = true;

        if (ok) {
          stats.correctMoves++;
          $feedback().textContent = `Correct! ${playerMove} was optimal (${best}).`;
          $feedback().classList.remove("lose");
          $feedback().classList.add("win");
        } else {
          $feedback().textContent = `Error! Optimal was ${best}. You chose ${playerMove}.`;
          $feedback().classList.remove("win");
          $feedback().classList.add("lose");
        }

        updateStatsUI();
      }
      /* ============================================================
         FLOW / DEALING  (Original Code Resumes Here)
         ============================================================ */

      function dealCard(h){
        if (deck.length === 0) deck = createAndShuffleDeck();
        h.push(deck.pop());
      }

      function dealInitialCards(useInitial){
        playerHand = [];
        dealerHand = [];

        if (useInitial && initialPlayerHand.length === 2 && initialDealerHand.length === 2){
          playerHand = [...initialPlayerHand];
          dealerHand = [...initialDealerHand];
        } else {
          // fresh deal
          dealCard(playerHand);   // Player 1
          dealCard(dealerHand);   // Dealer hole
          dealCard(playerHand);   // Player 2
          dealCard(dealerHand);   // Dealer upcard

          initialPlayerHand = [...playerHand];
          initialDealerHand = [...dealerHand];
        }
      }

      function initializeGame(){
        currentConfig = GAME_CONFIGS[$versionSelect().value];

        const perDeck = currentConfig.noTens ? 48 : 52;
        const min = currentConfig.decks * perDeck * 0.25;

        if (deck.length < min){
          deck = createAndShuffleDeck();
          $feedback().textContent = `Deck reshuffled (${deck.length} cards) for ${currentConfig.name}.`;
        } else {
          $feedback().textContent =
            `Ready for a new hand of ${currentConfig.name}. BJ Payout: ${currentConfig.bjPayout}.`;
        }

        playerHand = [];
        dealerHand = [];
        initialPlayerHand = [];
        initialDealerHand = [];

        gameActive = false;

        $playerHand().innerHTML = "";
        $dealerHand().innerHTML = "";
        $playerValue().textContent = "?";
        $dealerValue().textContent = "?";

        $doubleBtn().innerHTML = currentConfig.doubleLabel;
        $splitBtn().innerHTML  = currentConfig.splitLabel;

        toggleControls(false);
        $repeatHandBtn().disabled = true;

        requestStartHand();
      }
      /* ============================================================
         HAND CONSUMPTION / PAYWALL
         ============================================================ */

      function canConsumeHand(){
        refreshFreeDay();
        const freeUsed = getFreeUsed();
        const paid = getPaidHands();
        if (paid > 0) return true;
        return freeUsed < FREE_HAND_DAILY_LIMIT;
      }

      function consumeHand(){
        refreshFreeDay();

        let paid = getPaidHands();
        if (paid > 0){
          setPaidHands(paid - 1);
        } else {
          const used = getFreeUsed();
          if (used < FREE_HAND_DAILY_LIMIT){
            setFreeUsed(used + 1);
          }
        }

        updateHandBadge();
      }

      function requestStartHand(){
        if (!canConsumeHand()){
          showModal();
          $feedback().textContent =
            "You are out of hands. Buy an extra hand pack to keep training.";
          $feedback().classList.remove("win");
          $feedback().classList.add("lose");
          toggleControls(false);
          return;
        }
        startHand();
      }

      function startHand(){
        if (gameActive) return;

        gameActive = true;
        isFirstMove = true;
        $repeatHandBtn().disabled = true;

        consumeHand();

        dealInitialCards(false);
        updateDisplay();
        checkInitialBlackjack();
        toggleControls(gameActive);

        if (gameActive){
          $feedback().textContent =
            "Make your first move: Hit, Stand, Double, Split, or Surrender.";
          $feedback().classList.remove("win", "lose");
        }
      }

      function repeatHand(){
        if (gameActive || initialPlayerHand.length === 0) return;

        if (!canConsumeHand()){
          showModal();
          $feedback().textContent =
            "You are out of hands. Buy an extra hand pack to keep training.";
          $feedback().classList.remove("win");
          $feedback().classList.add("lose");
          toggleControls(false);
          return;
        }

        consumeHand();

        gameActive = true;
        isFirstMove = true;
        $repeatHandBtn().disabled = true;

        dealInitialCards(true);
        updateDisplay();
        checkInitialBlackjack();
        toggleControls(gameActive);

        if (gameActive){
          $feedback().textContent = "Repeating hand. Make your first move again.";
          $feedback().classList.remove("win", "lose");
        }
      }

      function restartStats(){
        stats = { totalHands: 0, correctMoves: 0 };
        setJSON(LS.STATS, stats);
        updateStatsUI();

        $feedback().textContent = "Stats reset.";
        $feedback().classList.remove("win");
        $feedback().classList.add("lose");

        requestStartHand();
      }

      function checkInitialBlackjack(){
        const pv = calculateHandValue(playerHand).value;
        const dv = calculateHandValue(dealerHand).value;

        if (pv === 21){
          if (dv === 21){
            endHand("Dealer and Player both have Blackjack (Push).");
          } else {
            endHand(`Player has Blackjack! Pays ${currentConfig.bjPayout}.`);
          }
        } else if (dv === 21){
          endHand("Dealer has Blackjack! Dealer Wins.");
        }
      }
      /* ============================================================
         DEALER PLAY + END OF HAND
         ============================================================ */

      function dealerPlay(){
        let { value: dv, isSoft } = calculateHandValue(dealerHand);

        while (dv < 17 || (currentConfig.dealerHitsSoft17 && dv === 17 && isSoft)){
          dealCard(dealerHand);
          updateDisplay(true);
          ({ value: dv, isSoft } = calculateHandValue(dealerHand));

          // Free Bet / Blackjack Switch rule: dealer 22 = push
          if (currentConfig.pushOnDealer22 && dv === 22) return;
        }
      }

      function endHand(msg){
        gameActive = false;
        updateDisplay(true);
        toggleControls(false);
        $repeatHandBtn().disabled = false;

        // Unless message already determined the win/loss (BJ, bust, etc.)
        // we must let dealer finish and resolve.
        if (
          !msg.includes("Blackjack") &&
          !msg.includes("Busts") &&
          !msg.includes("Surrender") &&
          !msg.includes("Doubles") &&
          !msg.includes("Split")
        ){
          dealerPlay();

          const pv = calculateHandValue(playerHand).value;
          const dv = calculateHandValue(dealerHand).value;

          if (pv > 21){
            msg = "Player Busts! Dealer Wins.";
          }
          else if (currentConfig.noTens && pv === 21){
            // Spanish 21 rule — player 21 always wins
            msg = "Player 21 Wins! (Spanish 21 Rule)";
          }
          else if (currentConfig.pushOnDealer22 && dv === 22){
            msg = "Dealer has 22. It's a Push (Free Bet/Switch Rule).";
          }
          else if (dv > 21){
            msg = "Dealer Busts! Player Wins!";
          }
          else if (pv > dv){
            msg = "Player Wins!";
          }
          else if (pv < dv){
            msg = "Dealer Wins.";
          }
          else {
            msg = "Push (Tie).";
          }
        }

        if (msg.includes("Wins!") && !msg.includes("Dealer")){
          $feedback().classList.remove("lose");
          $feedback().classList.add("win");
        } else if (
          msg.includes("Wins") ||
          msg.includes("Busts") ||
          msg.includes("Surrender")
        ){
          $feedback().classList.remove("win");
          $feedback().classList.add("lose");
        } else {
          $feedback().classList.remove("win", "lose");
        }

        $feedback().textContent = msg;
      }


      /* ============================================================
         PLAYER ACTIONS
         ============================================================ */

      function handleHit(){
        if (!gameActive) return;

        checkStrategy("Hit");

        dealCard(playerHand);
        updateDisplay();
        isFirstMove = false;
        toggleControls(true);

        const pv = calculateHandValue(playerHand).value;
        if (pv > 21){
          endHand("Player Busts!");
        } else if (pv === 21){
          handleStand();
        }
      }

      function handleStand(){
        if (!gameActive) return;
        checkStrategy("Stand");
        endHand("Player Stands.");
      }

      function handleDouble(){
        if (!gameActive || !isFirstMove) return;

        checkStrategy("Double");

        dealCard(playerHand);
        updateDisplay();

        endHand(
          `Player ${
            currentConfig.doubleLabel.includes("Free") ? "Free Doubles Down" : "Doubles Down"
          }.`
        );
      }

      function handleSplit(){
        if (
          !gameActive ||
          !isFirstMove ||
          playerHand.length !== 2 ||
          playerHand[0].rank !== playerHand[1].rank
        ){
          $feedback().textContent = "Cannot Split: only allowed on initial pair.";
          $feedback().classList.remove("win");
          $feedback().classList.add("lose");
          return;
        }

        checkStrategy("Split");

        endHand(
          `Strategy Check Recorded for ${
            currentConfig.splitLabel.includes("Free") ? "Free Split" : "Split"
          }. Start a new hand to continue.`
        );
      }

      function handleSurrender(){
        if (!gameActive || !isFirstMove || !currentConfig.hasSurrender) return;

        checkStrategy("Surrender");
        endHand("Player chooses to Surrender and loses half the bet.");
      }
      /* ============================================================
         EVENT LISTENERS / INITIALIZATION
         ============================================================ */

      window.addEventListener("load", () => {
        refreshFreeDay();

        if (!localStorage.getItem(LS.PAID_HANDS)) {
          setPaidHands(0);
        }

        updateStatsUI();
        updateHandBadge();

        // Main action buttons
        $hitBtn().addEventListener("click", handleHit);
        $standBtn().addEventListener("click", handleStand);
        $doubleBtn().addEventListener("click", handleDouble);
        $splitBtn().addEventListener("click", handleSplit);
        $surrenderBtn().addEventListener("click", handleSurrender);

        // Core controls
        $newHandBtn().addEventListener("click", requestStartHand);
        $repeatHandBtn().addEventListener("click", repeatHand);
        $restartStatsBtn().addEventListener("click", restartStats);

        // Modal & purchases
        $buyHandsTopBtn().addEventListener("click", showModal);
        $pack25Btn().addEventListener("click", () => AppleIAP.purchase("com.gtoshark.hands25"));
        $pack60Btn().addEventListener("click", () => AppleIAP.purchase("com.gtoshark.hands60"));
        $pack120Btn().addEventListener("click", () => AppleIAP.purchase("com.gtoshark.hands120"));
        $pack250Btn().addEventListener("click", () => AppleIAP.purchase("com.gtoshark.hands250"));
        $pack600Btn().addEventListener("click", () => AppleIAP.purchase("com.gtoshark.hands600"));
        $closeModalBtn().addEventListener("click", hideModal);
        $restoreBtn().addEventListener("click", () => AppleIAP.restore());

        // Initialize first game
        initializeGame();
      });
    </script>

    <!-- ============================================================
         OPTIONAL SERVICE WORKER
         ============================================================ -->
    <script>
      if ("serviceWorker" in navigator) {
        try {
          navigator.serviceWorker.register("service-worker.js");
        } catch (e) {
          console.log("Service Worker registration failed:", e);
        }
      }
    </script>

  </body>
  </html>
